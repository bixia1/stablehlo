# [RFC] Add Buffer Types

Status: In Review<br/>
Initial version: 07/29/2025<br/>
Last updated: 07/29/2025<br/>
Discussion thread: N/A

## Overview

This RFC proposes adding explicit buffer types to match the functionality of
the XLA/HLO buffer types. The XLA/HLO buffer type proposal is [here](https://docs.google.com/document/d/1v7WVJR_ozvUqjfts_EMbpzj9oJhxIgCOadC9ryzcwD0/edit?usp=drive_link&resourcekey=0-ZZaFZADBP4dJj6rQBNKGOg).

## Proposal

Change the Types section of the spec to include `BufferType` in `ValueType`:

```ebnf
ValueType ::= TensorType | QuantizedTensorType | TokenType | TupleType | BufferType
```

```ebnf
BufferType ::= 'memref' '<' Shape BufferElementType '>'
Shape ::= {DimensionSize 'x'}
DimensionSize ::= digit {digit} | '?'
```

**Buffer types** represent buffers. For example, in XLA, buffers are
multidimensional arrays with consistent storage. Similar to **tensor types**,
buffer types have a **shape** and an **element type**, where a shape represents
non-negative or unknown **dimension sizes** in the ascending order of the
corresponding **dimensions** (which are also called **axes**) numbered from `0`
to `R-1`. The number of dimensions `R` is called **rank**. For example,
`memref<2x3xf32>` is a buffer type with shape `2x3` and element type `f32`. It
has two dimensions (or, in other words, two axes) - 0th dimension and 1st
dimension - whose sizes are 2 and 3. Its rank is 2.

Buffers can be allocated using a `custom_call` to `pin` and deallocated via a
`custom_call` to `unpin`:

```mlir
%0 = "stablehlo.custom_call"(%arg0) {
    call_target_name = "pin",
    api_version = 4 : i32
  } : (tensor<2xf32>) -> memref<2xf32>
%1 = "stablehlo.custom_call"(%0) {
    call_target_name = "unpin",
    api_version = 4 : i32
  } : (memref<2xf32>) -> tensor<2xf32>
```

Only `custom_call` ops can read and write the content inside buffers. In this
case, the `output_operand_aliases` attribute of the `custom_call` op is used to
specify the operand and the output pair that refer to the same buffer:

```mlir
 %0 = "stablehlo.custom_call"(%arg0) {
    call_target_name = "foo",
    api_version = 4 : i32,
    output_operand_aliases = [
      #stablehlo.output_operand_alias<output_tuple_indices = [],
        operand_index = 0,
        operand_tuple_indices = []>]
  } : (memref<2xf32>) -> memref<2xf32>
```

The `custom_call` op is extended to allow buffers in `inputs` and `results`:

### custom_call

#### Semantics

Encapsulates an implementation-defined operation `call_target_name` that takes
`inputs` and `called_computations` and produces `results`. `has_side_effect`,
`backend_config` and `api_version` may be used to provide additional
implementation-defined metadata.

At the moment, this operation contains a fairly disorganized collection of
metadata which reflects organic evolution of its counterpart operation in
the XLA compiler. In the future, we are planning to unify this metadata
([#741](https://github.com/openxla/stablehlo/issues/741)).

#### Inputs

| Label | Name                  | Type                                                       |
|-------|-----------------------|------------------------------------------------------------|
| (I1)  | `inputs`              | variadic number of values or buffers                       |
| (I2)  | `call_target_name`    | constant of type `string`                                  |
| (I3)  | `has_side_effect`     | constant of type `i1`                                      |
| (I4)  | `backend_config`      | constant of type `string` or attribute dictionary          |
| (I5)  | `api_version`         | constant of type `si32`                                    |
| (I6)  | `called_computations` | variadic number of constants of type `string`              |

#### Outputs

| Name      | Type                                |
|-----------|-------------------------------------|
| `results` | variadic number of values or buffers|

#### Examples

```mlir
%results = "stablehlo.custom_call"(%input0) {
  call_target_name = "foo",
  has_side_effect = false,
  backend_config = {bar = 42 : i32},
  api_version = 4 : i32,
  called_computations = [@foo]
} : (tensor<f64>) -> tensor<f64>
```

The `get_tuple_element` op is extended to allow buffers:

### get_tuple_element

> Note: Per [StableHLO v1.0 Cleanup #2283](https://github.com/openxla/stablehlo/pull/2283),
> this op is being explored for deprecation as it appears to be unused by both
> frameworks and compilers. As such, it has limited compatibility guarantees
> (6 months).

#### Semantics

Extracts element at `index` position of the `operand` tuple and produces a
`result`. More formally, `result = operand[index]`.

#### Inputs

| Label | Name      | Type                    | Constraints |
|-------|-----------|-------------------------|-------------|
| (I1)  | `operand` | tuple                   | (C1), (C2)  |
| (I2)  | `index`   | constant of type `si32` | (C1), (C2)  |

#### Outputs

| Name     | Type                                       | Constraints |
|----------|--------------------------------------------|-------------|
| `result` | any supported type, including buffer types | (C2)        |

#### Constraints

* (C1) `0 <= index < size(operand)`.
* (C2) `type(result) = tuple_element_types(operand)[index]`.

#### Examples

```mlir
// %operand: ([1.0, 2.0], (3))
%result = "stablehlo.get_tuple_element"(%operand) <{index = 0 : i32}> : (tuple<tensor<2xf64>, tuple<tensor<i64>>>) -> tensor<2xf64>
// %result: [1.0, 2.0]
```

&nbsp;[More Examples](https://github.com/openxla/stablehlo/tree/main/stablehlo/tests/interpret/tuple_and_get_tuple_element.mlir)

The `tuple` op is extended to accept buffers:

### tuple

> Note: Per [StableHLO v1.0 Cleanup #2283](https://github.com/openxla/stablehlo/pull/2283),
> this op is being explored for deprecation as it appears to be unused by both
> frameworks and compilers. As such, it has limited compatibility guarantees
> (6 months).

#### Semantics

Produces a `result` tuple from values `val`.

#### Inputs

| Label | Name  | Type                                 | Constraints |
|-------|-------|--------------------------------------|-------------|
| (I1)  | `val` | variadic number of values or buffers | (C1)        |

#### Outputs

| Name     | Type  | Constraints |
|----------|-------|-------------|
| `result` | tuple | (C1)        |

#### Constraints

* (C1) `result` has type `tuple<E0, ..., EN-1>` where `Ei = type(val[i])`.

#### Examples

```mlir
// %val0: memref[1.0, 2.0]
// %val1: (3)
%result = "stablehlo.tuple"(%val0, %val1) : (memref<2xf32>, tuple<tensor<i32>>) -> tuple<memref<2xf32>, tuple<tensor<i32>>>
// %result: (memref[1.0, 2.0], (3))
```

&nbsp;[More Examples](https://github.com/openxla/stablehlo/tree/main/stablehlo/tests/interpret/tuple_and_get_tuple_element.mlir)

The `while` op is extended to allow buffers in `operands` and `results`:

### while

#### Semantics

Produces the output from executing `body` function 0 or more times while the
`cond` function outputs `true`. More formally, the semantics can be expressed
using Python syntax as follows:

```python
internal_state = operand
while cond(*internal_state):
  internal_state = body(*internal_state)
results = internal_state
```

The behavior of an infinite loop is TBD
([#383](https://github.com/openxla/stablehlo/issues/383)).

#### Inputs

| Label | Name      | Type                                                              | Constraints |
|-------|-----------|-------------------------------------------------------------------|-------------|
| (I1)  | `operand` | variadic number of tensors, quantized tensors, tokens, or buffers | (C1-C3)     |
| (I2)  | `cond`    | function                                                          | (C1)        |
| (I3)  | `body`    | function                                                          | (C2)        |

#### Outputs

| Name      | Type                                                             | Constraints |
|-----------|------------------------------------------------------------------|-------------|
| `results` | variadic number of tensors, quantized tensors, tokens or buffers | (C3)        |
